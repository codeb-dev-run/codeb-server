# CodeB CI/CD 의사결정 기록

> 이 문서는 CI/CD 시스템 설계 과정에서 내린 모든 결정과 그 이유를 기록합니다.
> 개발자들이 "왜 이렇게 했지?"라는 질문에 답할 수 있도록 작성되었습니다.

---

## 목차

1. [프로젝트 배경](#1-프로젝트-배경)
2. [핵심 결정들](#2-핵심-결정들)
3. [기술 스택 선택](#3-기술-스택-선택)
4. [제거한 것들](#4-제거한-것들)
5. [향후 고려사항](#5-향후-고려사항)

---

## 1. 프로젝트 배경

### 1.1 팀 상황

- **팀 규모**: 10명
- **서버**: Vultr VPS 1대 (2 vCPU, 4GB RAM)
- **기존 도구**: Podman, Caddy, PowerDNS, PM2
- **목표**: 100% 자동화된 배포 + 빌드 에러 자동 수정

### 1.2 핵심 요구사항

사용자(팀 리더)가 명확히 요청한 것:
1. "100% 자동 빌드에러 수정을 반복하게 하려는거고"
2. "절대 빌드할때 코드를 없에서 문제해결을 하지 않는 방식을 원해"
3. "10명이고, 배포할때 100% 자동화가 안되는 이유는 빌드에러일때 바이브코딩으로 디버깅 할꺼니깐"

---

## 2. 핵심 결정들

### 결정 #1: Self-Healing CI/CD 도입

**날짜**: 2025-01-10

**배경**:
- 빌드 에러가 발생하면 개발자가 수동으로 수정해야 함
- 특히 TypeScript 타입 에러나 lint 에러는 패턴이 명확함
- Claude Code로 자동 수정하면 개발자 시간 절약

**결정**:
빌드 실패 시 Claude API를 호출하여 에러를 분석하고 자동 수정

**대안들**:
| 옵션 | 검토 결과 |
|------|----------|
| GitHub Copilot Autofix | Preview 단계, 기능 제한적 |
| ESLint --fix만 사용 | 타입 에러 수정 불가 |
| 수동 수정 | 개발자 시간 낭비 |

**위험 요소**:
- AI가 잘못된 수정을 할 수 있음 → **검증 단계 추가**
- 무한 루프 가능성 → **최대 5회 제한**
- 코드 품질 저하 → **No-Deletion 원칙**

---

### 결정 #2: No-Deletion 원칙

**날짜**: 2025-01-10

**배경**:
AI가 빌드 에러를 "수정"할 때 가장 쉬운 방법은:
- 에러가 나는 코드 삭제
- @ts-ignore 추가
- 테스트 skip

이것은 수정이 아니라 **회피**이며, 코드 품질을 저하시킴

**결정**:
다음 패턴이 포함된 수정은 자동 거부:
```
@ts-ignore, @ts-nocheck, eslint-disable, .skip(, as any, : any
```

또한 `삭제 > 추가` 인 경우 자동 거부

**대안들**:
| 옵션 | 검토 결과 |
|------|----------|
| 패턴 금지만 | 코드 삭제로 우회 가능 |
| 삭제 비율만 | @ts-ignore로 우회 가능 |
| 둘 다 적용 | **채택** |

**구현**:
```bash
# 삭제/추가 비율 검사
if [ "$DELETIONS" -gt "$ADDITIONS" ]; then
  exit 1
fi

# 금지 패턴 검사
if git diff | grep -E "@ts-ignore|eslint-disable"; then
  exit 1
fi
```

---

### 결정 #3: GitHub Actions 사용 (Self-Hosted Runner 미사용)

**날짜**: 2025-01-10

**배경**:
빌드를 어디서 할 것인가?

**결정**:
GitHub Actions의 `ubuntu-latest` 사용

**대안들**:
| 옵션 | 장점 | 단점 | 결론 |
|------|------|------|------|
| GitHub Actions | 무료 2000분, 관리 불필요 | 외부 네트워크 | **채택** |
| Self-Hosted Runner | 빠른 캐시 | 서버 리소스 사용 | 미채택 |
| GitHub Codespaces | 개발 환경 일치 | 비용 | 미채택 |

**선택 이유**:
1. **서버 보호**: 2 vCPU로 빌드하면 운영 서비스 영향
2. **비용**: 10인 팀이면 2000분/월 충분
3. **관리**: Self-Hosted Runner 업데이트/모니터링 불필요

**근거 계산**:
```
월 근무일: 22일
하루 평균 push: 10회 (10명 × 1회)
빌드당 시간: 3분
월 빌드 시간: 22 × 10 × 3 = 660분
무료 한도: 2000분
여유: 1340분 (67%)
```

---

### 결정 #4: Rolling 배포만 사용

**날짜**: 2025-01-10

**배경**:
MCP 서버에 Blue-Green, Canary 배포 전략이 구현되어 있었음

**결정**:
Rolling 배포만 사용, 나머지 전략 비활성화

**대안들**:
| 전략 | 필요 조건 | 팀 상황 | 결론 |
|------|----------|---------|------|
| Rolling | 최소 리소스 | 충족 | **채택** |
| Blue-Green | 2배 리소스 | 불충족 (4GB RAM) | 미채택 |
| Canary | 트래픽 분산 | 불필요 (내부 서비스) | 미채택 |

**선택 이유**:
1. **리소스**: 서버 1대로 Blue-Green 불가
2. **복잡도**: 10인 팀에 트래픽 분산 로직 과도함
3. **충분한 안정성**: 헬스체크 + 자동 롤백으로 충분

---

### 결정 #5: Podman 유지 (Docker 미전환)

**날짜**: 2025-01-10

**배경**:
서버에 이미 Podman 3.4.4가 설치되어 있음

**결정**:
Docker로 전환하지 않고 Podman 유지

**대안들**:
| 옵션 | 장점 | 단점 |
|------|------|------|
| Docker | 문서 풍부, 업계 표준 | daemon 필요, 재설치 필요 |
| Podman | rootless, 이미 설치됨 | 일부 호환성 이슈 |

**선택 이유**:
1. **보안**: rootless 실행으로 서버 보안 강화
2. **호환성**: `alias docker=podman`으로 대부분 호환
3. **비용**: 재설치 시간/위험 회피

---

### 결정 #6: ghcr.io 사용

**날짜**: 2025-01-10

**배경**:
Docker 이미지를 어디에 저장할 것인가?

**결정**:
GitHub Container Registry (ghcr.io) 사용

**대안들**:
| 옵션 | 비용 | 통합성 | 결론 |
|------|------|--------|------|
| ghcr.io | 무료 | GitHub 완벽 통합 | **채택** |
| Docker Hub | 무료 (제한) | 별도 인증 필요 | 미채택 |
| Self-Hosted | 무료 | 관리 필요 | 미채택 |
| AWS ECR | 유료 | AWS 필요 | 미채택 |

**선택 이유**:
1. **통합**: GitHub Actions에서 자동 인증
2. **비용**: Private 저장소 무료
3. **관리**: Self-Hosted Registry 운영 불필요

---

## 3. 기술 스택 선택

### 3.1 서버 인프라

| 구성요소 | 선택 | 이유 |
|---------|------|------|
| 컨테이너 | Podman | 이미 설치됨, rootless |
| 웹서버 | Caddy | 자동 HTTPS, 설정 간단 |
| DNS | PowerDNS | 자체 DNS 관리 필요 |
| 프로세스 관리 | PM2 | Node.js 앱에 최적화 |
| 데이터베이스 | PostgreSQL | 표준, 안정적 |
| 캐시 | Redis | 표준, 빠름 |

### 3.2 CI/CD 도구

| 구성요소 | 선택 | 이유 |
|---------|------|------|
| CI | GitHub Actions | 무료, 통합 |
| CD | SSH + Podman | 간단, 직접 제어 |
| Registry | ghcr.io | GitHub 통합 |
| 보안 스캔 | Trivy | 무료, 강력 |
| 시크릿 스캔 | gitleaks | 무료, 정확 |
| SBOM | syft | 표준 지원 |

### 3.3 MCP 서버

| 기능 | 도구 수 | 목적 |
|------|--------|------|
| 배포 | 5 | deploy, healthcheck, rollback 등 |
| Self-Healing | 4 | 빌드 에러 자동 수정 |
| 모니터링 | 6 | 디스크, SSL, 백업 등 |
| 환경 관리 | 2 | env, secrets |
| 워크플로우 | 3 | workflow 관리 |

---

## 4. 제거한 것들

### 4.1 불필요한 복잡도

| 제거 항목 | 이유 |
|----------|------|
| Blue-Green 배포 | 리소스 부족, 10인 팀에 과도함 |
| Canary 배포 | 트래픽 분산 불필요 |
| Prometheus/Grafana | 과도한 모니터링, 간단한 스크립트로 충분 |
| Self-Hosted Registry | ghcr.io로 충분 |
| Kubernetes | 1대 서버에 불필요 |

### 4.2 MCP 도구 간소화

기존 35개 → 20개 핵심 도구로 간소화

**제거된 도구들**:
- 복잡한 배포 전략 관련
- 중복 기능
- 사용되지 않을 기능

---

## 5. 향후 고려사항

### 5.1 팀 성장 시

| 조건 | 추가 고려 |
|------|----------|
| 20명+ | Blue-Green 재검토 |
| 50명+ | Canary 배포 도입 |
| 100명+ | Kubernetes 전환 |

### 5.2 서버 확장 시

| 조건 | 추가 고려 |
|------|----------|
| 서버 2대 | 로드 밸런싱 |
| 서버 3대+ | Kubernetes |
| 멀티 리전 | CDN, 분산 배포 |

### 5.3 기능 추가 시

| 요구사항 | 추가 고려 |
|---------|----------|
| 상세 메트릭 | Prometheus 재도입 |
| 시각화 | Grafana 재도입 |
| 로그 집계 | Loki 또는 ELK |

---

## 변경 이력

| 날짜 | 결정 | 담당자 |
|------|------|--------|
| 2025-01-10 | Self-Healing CI/CD 도입 | 팀 리더 |
| 2025-01-10 | No-Deletion 원칙 수립 | 팀 리더 |
| 2025-01-10 | GitHub Actions 선택 | 팀 리더 |
| 2025-01-10 | Rolling 배포만 사용 | 팀 리더 |
| 2025-01-10 | MCP 도구 간소화 | 팀 리더 |
