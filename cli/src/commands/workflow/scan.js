/**
 * Workflow Scan Module
 *
 * Scans project deployment status and detects issues
 * - Blue-Green Slot API scan (primary)
 * - Legacy SSH-based scan (fallback)
 * - Resource scanning (DB, Redis, Storage)
 */

import chalk from 'chalk';
import ora from 'ora';
import { readFile } from 'fs/promises';
import { existsSync, readdirSync } from 'fs';
import { join } from 'path';
import { getServerHost, getServerUser, getCliVersion } from '../../lib/config.js';
import { mcpClient } from '../../lib/mcp-client.js';

// ============================================================================
// Constants
// ============================================================================

// Current CLI version for comparison
const CURRENT_CLI_VERSION = getCliVersion();

// Deployment methods
const DEPLOY_METHODS = {
  SSH: 'SSH',
  MCP_API: 'MCP-API',
  UNKNOWN: 'Unknown'
};

// ============================================================================
// GitHub Actions Analysis
// ============================================================================

/**
 * Analyze GitHub Actions workflow file
 * @param {string} content - Workflow file content
 * @returns {Object} Analysis result
 */
export function analyzeGitHubActions(content) {
  const usesSSHDeploy = content.includes('appleboy/ssh-action') || content.includes('ssh-action');
  const usesMcpApi = content.includes('api.codeb.kr') ||
                     content.includes('MCP_API') ||
                     content.includes('workflow_scan') ||
                     content.includes('deploy:') && content.includes('curl');

  // Extract version from comment
  const versionMatch = content.match(/Generated by CodeB CLI v([\d.]+)/);
  const version = versionMatch?.[1] || 'unknown';

  // Determine deployment method
  let deployMethod = DEPLOY_METHODS.UNKNOWN;
  if (usesMcpApi) {
    deployMethod = DEPLOY_METHODS.MCP_API;
  } else if (usesSSHDeploy) {
    deployMethod = DEPLOY_METHODS.SSH;
  }

  return {
    exists: true,
    version,
    deployMethod,
    usesMcpApi,
    usesSSHDeploy,
    hasQuadlet: content.includes('Quadlet') || content.includes('quadlet'),
    hasBlueGreen: content.includes('blue') && content.includes('green'),
    // Version check - warn if significantly outdated
    isOutdated: version !== 'unknown' && version < '3.0.0'
  };
}

// ============================================================================
// Blue-Green Slot API Scan (Primary)
// ============================================================================

/**
 * Scan using Blue-Green Slot API
 * @param {string} projectName - Project name
 * @param {Object} options - Scan options
 * @returns {Promise<Object>} Scan result
 */
export async function scanBlueGreen(projectName, options = {}) {
  const spinner = ora('Scanning with Blue-Green Slot API...').start();

  try {
    const result = await mcpClient.workflowScan(projectName, {
      gitRepo: options.gitRepo,
      autoFix: options.autoFix || false,
    });

    spinner.succeed('Scan completed (Blue-Green Slot API)');

    // Display result
    console.log(chalk.blue.bold('\nüìä Blue-Green Slot Workflow Scan\n'));

    if (result.error) {
      console.log(chalk.red(`‚ùå Error: ${result.error}`));
      return result;
    }

    // Current Status
    if (result.currentStatus) {
      console.log(chalk.yellow('üîç Current Status:'));
      const status = result.currentStatus;
      console.log(chalk.gray(`  Project: ${status.projectName || projectName}`));
      console.log(chalk.gray(`  Registered: ${status.isRegistered ? '‚úÖ' : '‚ùå'}`));

      if (status.slots) {
        console.log(chalk.gray(`  Active Slot: ${status.slots.activeSlot || 'none'}`));
        console.log(chalk.gray(`  Blue: ${status.slots.blue?.status || 'empty'}`));
        console.log(chalk.gray(`  Green: ${status.slots.green?.status || 'empty'}`));
      }

      if (status.domain) {
        console.log(chalk.gray(`  Domain: ${status.domain}`));
      }
    }

    // New Workflow
    if (result.workflow) {
      console.log(chalk.yellow('\nüìÑ Generated Workflow:'));
      console.log(chalk.gray(`  Version: ${result.workflow.version}`));
      console.log(chalk.gray(`  Type: ${result.workflow.type}`));
      if (result.workflow.features) {
        console.log(chalk.gray(`  Features: ${result.workflow.features.join(', ')}`));
      }
    }

    // Recommendations
    if (result.recommendations?.length > 0) {
      console.log(chalk.yellow('\nüí° Recommendations:'));
      result.recommendations.forEach((rec, i) => {
        console.log(chalk.cyan(`  ${i + 1}. ${rec}`));
      });
    }

    // Next Steps
    if (result.nextSteps?.length > 0) {
      console.log(chalk.yellow('\nüöÄ Next Steps:'));
      result.nextSteps.forEach((step, i) => {
        console.log(chalk.green(`  ${i + 1}. ${step}`));
      });
    }

    console.log();
    return result;

  } catch (error) {
    spinner.fail('Scan failed');

    // Check if it's an API error and fall back to legacy scan
    if (error.message.includes('API') ||
        error.message.includes('fetch') ||
        error.message.includes('ECONNREFUSED')) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  MCP API unavailable, falling back to legacy scan...\n'));
      return scanLegacy(projectName, options);
    }

    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    throw error;
  }
}

// ============================================================================
// Legacy SSH-based Scan (Fallback)
// ============================================================================

/**
 * Scan using legacy SSH method
 * @param {string} projectName - Project name
 * @param {Object} options - Scan options
 * @returns {Promise<Object>} Scan result
 */
export async function scanLegacy(projectName, options = {}) {
  const spinner = ora('Scanning deployment status...').start();
  const serverHost = options.host || getServerHost();
  const serverUser = options.user || getServerUser();

  try {
    const report = {
      local: { quadlet: [], github: null, dockerfile: false, env: false },
      server: { containers: [], quadlet: [], registry: null, ports: [], network: null },
      comparison: { needsMigration: false, issues: [], missingServices: [], networkIssues: [] }
    };

    // 1. Scan Local Files
    spinner.text = 'Scanning local files...';

    // Check for quadlet directory
    if (existsSync('quadlet')) {
      const quadletFiles = readdirSync('quadlet').filter(f => f.endsWith('.container'));
      report.local.quadlet = quadletFiles;
    }

    // Check for GitHub Actions
    const ghPath = '.github/workflows/deploy.yml';
    if (existsSync(ghPath)) {
      const content = await readFile(ghPath, 'utf-8');
      report.local.github = analyzeGitHubActions(content);
    }

    // Check for Dockerfile
    report.local.dockerfile = existsSync('Dockerfile');

    // Check for .env files
    report.local.env = existsSync('.env') || existsSync('.env.local') || existsSync('.env.example');

    // 2. Scan Server (via SSH)
    spinner.text = 'Scanning server status...';

    const { execSync } = await import('child_process');

    try {
      // Get running containers with network info
      const containersCmd = `ssh ${serverUser}@${serverHost} "podman ps -a --format '{{.Names}}|{{.Image}}|{{.Status}}|{{.Ports}}|{{.Networks}}' 2>/dev/null"`;
      const containersOutput = execSync(containersCmd, { encoding: 'utf-8', timeout: 30000 }).trim();

      if (containersOutput) {
        report.server.containers = containersOutput.split('\n').map(line => {
          const [name, image, status, ports, networks] = line.split('|');
          return { name, image, status, ports, networks };
        });
      }

      // Get Quadlet files on server
      const quadletCmd = `ssh ${serverUser}@${serverHost} "ls /etc/containers/systemd/*.container 2>/dev/null | xargs -I {} basename {}"`;
      const quadletOutput = execSync(quadletCmd, { encoding: 'utf-8', timeout: 30000 }).trim();

      if (quadletOutput) {
        report.server.quadlet = quadletOutput.split('\n').filter(Boolean);
      }

      // Get project registry
      const registryCmd = `ssh ${serverUser}@${serverHost} "cat /opt/codeb/config/project-registry.json 2>/dev/null"`;
      try {
        const registryOutput = execSync(registryCmd, { encoding: 'utf-8', timeout: 30000 });
        report.server.registry = JSON.parse(registryOutput);
      } catch {
        report.server.registry = null;
      }

      // Get used ports
      const portsCmd = `ssh ${serverUser}@${serverHost} "ss -tlnp 2>/dev/null | grep LISTEN | awk '{print \\$4}' | grep -oE '[0-9]+$' | sort -n | uniq"`;
      const portsOutput = execSync(portsCmd, { encoding: 'utf-8', timeout: 30000 }).trim();
      report.server.ports = portsOutput.split('\n').filter(Boolean).map(Number);

      // Check codeb-network exists
      try {
        const networkCmd = `ssh ${serverUser}@${serverHost} "podman network inspect codeb-network --format '{{.Subnets}}' 2>/dev/null"`;
        const networkOutput = execSync(networkCmd, { encoding: 'utf-8', timeout: 30000 }).trim();
        report.server.network = { exists: true, subnet: networkOutput };
      } catch {
        report.server.network = { exists: false, subnet: null };
      }

    } catch (sshError) {
      report.server.error = `SSH connection failed: ${sshError.message}`;
    }

    // 3. Compare and analyze
    spinner.text = 'Analyzing differences...';
    analyzeReport(report, projectName);

    spinner.succeed('Scan completed');

    // Display Report
    displayReport(report, projectName);

    return report;

  } catch (error) {
    spinner.fail('Scan failed');
    console.log(chalk.red(`\n‚ùå Error: ${error.message}\n`));
    throw error;
  }
}

// ============================================================================
// Report Analysis
// ============================================================================

/**
 * Analyze report and detect issues
 * @param {Object} report - Scan report
 * @param {string} projectName - Project name
 */
function analyzeReport(report, projectName) {
  // Check if project exists on server
  if (projectName) {
    const serverHasProject = report.server.containers.some(c => c.name.includes(projectName));
    const localHasQuadlet = report.local.quadlet.some(f => f.includes(projectName));

    if (serverHasProject && !localHasQuadlet) {
      report.comparison.issues.push(`Project "${projectName}" exists on server but no local quadlet files`);
      report.comparison.needsMigration = true;
    }

    if (!serverHasProject && localHasQuadlet) {
      report.comparison.issues.push(`Local quadlet files exist but project not deployed on server`);
    }
  }

  // Check GitHub Actions deployment method
  if (report.local.github) {
    // Warn if using SSH instead of MCP API (SSHÎäî Admin Ï†ÑÏö©)
    if (report.local.github.usesSSHDeploy && !report.local.github.usesMcpApi) {
      report.comparison.issues.push('SSH deploy detected (Admin only) - run "we workflow migrate" for MCP API');
      report.comparison.needsMigration = true;
    }

    // Warn if version is significantly outdated
    if (report.local.github.isOutdated) {
      report.comparison.issues.push(`GitHub Actions workflow is outdated (v${report.local.github.version})`);
      report.comparison.needsMigration = true;
    }
  }

  // Check for missing services
  if (report.server.registry?.projects && !report.server.error) {
    for (const [projName, projData] of Object.entries(report.server.registry.projects)) {
      if (projectName && !projName.includes(projectName)) continue;

      const ports = projData.ports || {};
      const containerNames = report.server.containers.map(c => c.name);

      // Check for missing PostgreSQL
      if (ports.app && !ports.postgres) {
        const hasPostgres = containerNames.some(n => n.includes(projName) && n.includes('postgres'));
        if (!hasPostgres) {
          report.comparison.missingServices.push({
            project: projName,
            service: 'postgres',
            message: `Missing PostgreSQL for project "${projName}"`
          });
        }
      }

      // Check for missing Redis
      if (ports.app && !ports.redis) {
        const hasRedis = containerNames.some(n => n.includes(projName) && n.includes('redis'));
        if (!hasRedis) {
          report.comparison.missingServices.push({
            project: projName,
            service: 'redis',
            message: `Missing Redis for project "${projName}"`
          });
        }
      }
    }
  }

  // Check network issues
  if (!report.server.error) {
    if (!report.server.network?.exists) {
      report.comparison.networkIssues.push({
        type: 'missing_network',
        message: 'codeb-network does not exist on server'
      });
    }

    const containersOnWrongNetwork = report.server.containers.filter(c => {
      if (projectName && !c.name.includes(projectName)) return false;
      return c.networks && c.networks !== 'codeb-network';
    });

    if (containersOnWrongNetwork.length > 0) {
      report.comparison.networkIssues.push({
        type: 'wrong_network',
        message: `${containersOnWrongNetwork.length} containers not on codeb-network`,
        containers: containersOnWrongNetwork.map(c => ({ name: c.name, network: c.networks }))
      });
    }
  }
}

// ============================================================================
// Report Display
// ============================================================================

/**
 * Display scan report
 * @param {Object} report - Scan report
 * @param {string} projectName - Project name
 */
function displayReport(report, projectName) {
  console.log(chalk.blue.bold('\nüìä Deployment Status Report\n'));

  // Local Status
  console.log(chalk.yellow('üìÅ Local Files:'));
  console.log(chalk.gray(`  Quadlet files: ${report.local.quadlet.length > 0 ? report.local.quadlet.join(', ') : 'None'}`));

  if (report.local.github) {
    const gh = report.local.github;
    console.log(chalk.gray(`  GitHub Actions: v${gh.version} (${gh.deployMethod}${gh.usesMcpApi ? ' ‚úÖ' : ''})`));
  } else {
    console.log(chalk.gray(`  GitHub Actions: Not found`));
  }

  console.log(chalk.gray(`  Dockerfile: ${report.local.dockerfile ? '‚úÖ' : '‚ùå'}`));
  console.log(chalk.gray(`  Environment files: ${report.local.env ? '‚úÖ' : '‚ùå'}`));

  // Server Status
  console.log(chalk.yellow('\nüñ•Ô∏è  Server Status:'));
  if (report.server.error) {
    console.log(chalk.red(`  ${report.server.error}`));
  } else {
    console.log(chalk.gray(`  Running containers: ${report.server.containers.length}`));
    if (report.server.containers.length > 0) {
      report.server.containers.forEach(c => {
        const statusColor = c.status.includes('Up') ? chalk.green : chalk.red;
        console.log(chalk.gray(`    ‚Ä¢ ${c.name}: ${statusColor(c.status)}`));
      });
    }
    console.log(chalk.gray(`  Quadlet files: ${report.server.quadlet.length}`));
    console.log(chalk.gray(`  Registry projects: ${report.server.registry?.projects ? Object.keys(report.server.registry.projects).length : 0}`));
  }

  // Issues
  if (report.comparison.issues.length > 0) {
    console.log(chalk.yellow('\n‚ö†Ô∏è  Issues Found:'));
    report.comparison.issues.forEach(issue => {
      console.log(chalk.red(`  ‚Ä¢ ${issue}`));
    });

    if (report.comparison.needsMigration) {
      console.log(chalk.cyan('\nüí° Recommendation: Run "we workflow migrate" to update'));
    }
  }

  // Missing Services
  if (report.comparison.missingServices.length > 0) {
    console.log(chalk.yellow('\nüîç Missing Services Detected:'));
    report.comparison.missingServices.forEach(ms => {
      console.log(chalk.red(`  ‚Ä¢ ${ms.message}`));
      console.log(chalk.cyan(`    Fix: we workflow add-service ${ms.project} --service ${ms.service}`));
    });
  }

  // Network Issues
  if (report.comparison.networkIssues.length > 0) {
    console.log(chalk.yellow('\nüåê Network Issues Detected:'));
    report.comparison.networkIssues.forEach(ni => {
      console.log(chalk.red(`  ‚Ä¢ ${ni.message}`));
      if (ni.type === 'missing_network') {
        console.log(chalk.cyan('    Fix: we workflow fix-network'));
      } else if (ni.type === 'wrong_network' && ni.containers) {
        ni.containers.slice(0, 5).forEach(c => {
          console.log(chalk.gray(`      - ${c.name} (current: ${c.network})`));
        });
        if (ni.containers.length > 5) {
          console.log(chalk.gray(`      ... and ${ni.containers.length - 5} more`));
        }
        console.log(chalk.cyan('    Fix: we workflow fix-network'));
      }
    });
  }

  // Summary
  const totalIssues = report.comparison.issues.length +
                      report.comparison.missingServices.length +
                      report.comparison.networkIssues.length;

  if (totalIssues === 0) {
    console.log(chalk.green('\n‚úÖ No issues found'));
  } else {
    console.log(chalk.yellow(`\nüìä Summary: ${totalIssues} issue(s) found`));
  }

  console.log();
}

// ============================================================================
// Internal Scan (for migrate command)
// ============================================================================

/**
 * Internal scan without display (for other commands)
 * @param {string} projectName - Project name
 * @param {Object} options - Scan options
 * @returns {Promise<Object>} Scan result
 */
export async function scanInternal(projectName, options = {}) {
  const serverHost = options.host || getServerHost();
  const serverUser = options.user || getServerUser();

  const report = {
    local: { quadlet: [], github: null, dockerfile: false, env: false },
    server: { containers: [], quadlet: [], registry: null },
    comparison: { needsMigration: false, issues: [] }
  };

  // Scan local
  if (existsSync('quadlet')) {
    report.local.quadlet = readdirSync('quadlet').filter(f => f.endsWith('.container'));
  }

  const ghPath = '.github/workflows/deploy.yml';
  if (existsSync(ghPath)) {
    const content = await readFile(ghPath, 'utf-8');
    report.local.github = analyzeGitHubActions(content);
  }

  report.local.dockerfile = existsSync('Dockerfile');
  report.local.env = existsSync('.env') || existsSync('.env.local');

  // Scan server - Try MCP first
  try {
    const mcpConnected = await mcpClient.ensureConnected();
    if (mcpConnected) {
      const ssotData = await mcpClient.callTool('ssot_get', {});
      if (ssotData && !ssotData.error) {
        report.server.registry = ssotData;
      }
    }
  } catch {
    // Fall back to SSH
    const { execSync } = await import('child_process');
    try {
      const cmd = `ssh ${serverUser}@${serverHost} "cat /opt/codeb/config/project-registry.json 2>/dev/null"`;
      const output = execSync(cmd, { encoding: 'utf-8', timeout: 30000 });
      report.server.registry = JSON.parse(output);
    } catch {
      report.server.registry = null;
    }
  }

  // Analyze
  if (report.local.github) {
    if (report.local.github.isOutdated) {
      report.comparison.issues.push(`Old CLI version (${report.local.github.version})`);
      report.comparison.needsMigration = true;
    }
    if (!report.local.github.usesMcpApi) {
      report.comparison.issues.push('Should use MCP API for deployment');
      report.comparison.needsMigration = true;
    }
  }

  return report;
}

// ============================================================================
// Exports
// ============================================================================

export { DEPLOY_METHODS };

export default {
  scanBlueGreen,
  scanLegacy,
  scanInternal,
  analyzeGitHubActions,
  DEPLOY_METHODS
};
